= Camel-Quarkus Demo

== How to Prepare the Demo

[source,shell]
----
# Start a cluster, for instance:
crc start -b crc-linux-1.8.0-amd64/crc_libvirt_4.3.8.crcbundle

# Login
oc login -u kubeadmin -p <PASSWORD> https://api.crc.testing:6443

# Clone the git demo project locally
cd camel-quarkus-demo
git clone https://github.com/aldettinger/camel-quarkus-hellos.git camel-quarkus-hellos

# Deploy hellos project to the crc cluster
cd camel-hellos
mvnu clean package -Dquarkus.kubernetes.deploy=true

# Check that the jvm mode pod is working
curl -X PUT -d '{ "room" : { "temperature" : 35}}' http://hello-camel-quarkus-jvm-mode-default.apps-crc.testing/hello-camel-quarkus-jvm-mode --resolve hello-camel-quarkus-jvm-mode-default.apps-crc.testing:$(crc ip)
curl http://hello-camel-quarkus-jvm-mode-default.apps-crc.testing/hello-camel-quarkus-jvm-mode --resolve hello-camel-quarkus-jvm-mode-default.apps-crc.testing:$(crc ip)

# Check that the native mode pod is working
# ERROR logs from pdfont are excluded as the log level is set to FATAL
curl -X PUT -d '{ "room" : { "temperature" : 20}}' http://hello-camel-quarkus-native-mode-default.apps-crc.testing/hello-camel-quarkus-native-mode --resolve hello-camel-quarkus-native-mode-default.apps-crc.testing:$(crc ip)
curl http://hello-camel-quarkus-native-mode-default.apps-crc.testing/hello-camel-quarkus-native-mode --resolve hello-camel-quarkus-native-mode-default.apps-crc.testing:$(crc ip)

# Delete my-quarkus project from eclipse if any
# Delete directroy if any:
rm -fr ~/dev/demos/camel-quarkus-demo/my-quarkus-project/

Open terminator
Split window horizontally #And in both terminal do:
cd ~/dev/demos/camel-quarkus-demo/
----

== How to Run the Demo

[source,shell]
----
mvnu io.quarkus:quarkus-maven-plugin:1.5.0.Final:create
# Keep all default values

# Show extensions
cd my-quarkus-project
mvnu quarkus:add-extensions -Dextensions=platform-http,jsonpath,pdf

# Import in eclipse: ~/dev/demos/camel-quarkus-demo/my-quarkus-project

Create MyRouteBuilder class:
public class MyRouteBuilder extends RouteBuilder {
    @Override
    public void configure() {
        from("platform-http:/hello").setBody(constant("Hello From Camel Quarkus !"));
    }
}

# Show the dev mode, update message and curl again
mvnu quarkus:dev

# Get the first body, change, and show update in the blink of an eye
http :8080/hello

# Add MyRouteBuilderTest:
import static io.restassured.RestAssured.given;

@QuarkusTest
public class MyRouteBuilderTest {
    @Test
    void getHelloShouldReturnHttp200(){
        given().when().get("/hello").then().statusCode(200);
    }
}

# Display the size of the runner + lib + java
du -chLs target/my-quarkus-project-1.0-SNAPSHOT-runner.jar target/lib ${JAVA_HOME}

# Show the jvm mode from the command line
java -jar target/my-quarkus-project-1.0-SNAPSHOT-runner.jar

# Notice the camel boot time
# Define Resident Set Size (everything in RAM, shared library + stack + heap) and display usage in KiB
ps -o rss,cmd $(pgrep -f quarkus)

# Proves that it run but ONLY after having checked initial memory
http :8080/hello

# Then show native mode, 3 minutes speach while native compilation occurs
# Recap JVM mode optimization (closed world + build time configuration)... TODO
# Native mode, graalvm, static code analysis, remove jit, execute static initializer, take heap snapshot... TODO
mvnu package -P native

# Show size first (just enough of application code / third party libs / jdk)
du -chLs target/my-quarkus-project-1.0-SNAPSHOT-runner*
# Then boot time
target/my-quarkus-project-1.0-SNAPSHOT-runner
# Then rss mem
ps -o rss,cmd $(pgrep -f quarkus)
# And finally show it working
http :8080/hello

# Add default message:
# setBody(simple("{{camel.default-msg}}")). # in route
# camel.default-msg = COLD # in src/main/resources/applications.properties
http :8080/hello

# Add some jsonpath logic in route:
#    @Override
#    public void configure() throws Exception {
#        from("platform-http:/hello").
#            choice().when(jsonpath("$.room[?(@.temperature > 30)]")).
#                setBody(constant("HOT")).
#            otherwise().
#                setBody(constant("COLD")).
#            end();
#    }
http :8080/hello <<< '{room: {temperature: 30}}'

# Finally, add pdf generation
# .to("pdf:create?fontSize=26").convertBodyTo(byte[].class);
http :8080/hello <<< '{room : {temperature : 40}}' > test.pdf
firefox test.pdf

# Then run the demo comparing camel-hellos project, e.g a summary like
# Implement standalone, and perharps spring boot
						boot	rss		size
 standalone			1s		1Mo		1Mo
 spring-boot			2s		2Mo		2Mo
 quarkus-jvm-mode		3s		3Mo		3Mo
 quarkus-native-mode	4s		4Mo		4Mo
camel-hellos/compare.sh

# Then show the resulting densification in a crc cluster with quotas mem ? cpu ? (ideally all hellos project but could be only jvm vs native)
# Launch some requests to scale pods, we would expect native to exhibit a better densification
At first, it's possible to set replicas = 20 and show the time it takes in OpenShift DeploymentConfig view

Raw notes for demo/improvements:
Interest of native mode:
JIT vs AOT => faster startup since code is already pre-compiled into efficient machine code
No need to include infrastructure to load and optimize code at run time => less memory
static analysis to embed what's used from the JDK, 3rd party libs and JVM code
Tool "hey" to push a burden like "hey url"
vscode to have auto completion ?
init project from quarkus.io ?
compare.sh compare disk/boot/rss BEFORE the first request, so do the same during the demo
Show quarkus live reload ? (update the dev and show result directly in the cluster)
Does quarkus really improve disk size in jvm mode only ? integrate an unused class and check size for instance ?
Does quarkus really improve memory size in jvm mode only ? how ?
Finish the demo explaining how could help with camel-quarkus project
An interest of fast startup is that it improve disposability (help to scale, move process to another node...)
On a public cloud, densification allows the use of smaller instances to run an application so reduce costs
cloud provider portability => need kubernetes to abstract cloud specific services like object bucket storage => than we still need a framework to use those services => Quarkus

When I boot offline, then start crc, I get the issue below:
ERRO Failed to query DNS from host: lookup api.crc.testing on [::1]:53: read udp [::1]:36955->[::1]:53: read: connection refused
Maybe an app listening on port 53 ? Only when started without network ?
Then, I replug the network, start vpn and I can start crc again
----
